R --  funct register0 register1 opcode
I --  const register opcode
B --  const opcode




ADD A, rX
opcode -> soma
número do registrador
funct -> soma

LD rX, const
opcode -> soma
número do registrador
funct -> soma


SUB A, rX
opcode -> soma
número do registrador
funct -> sub

SUBI A, const
opcode -> imediato
constante n Bits
funct -> sub

opcional:
  ADDI A, const
  opcode -> imediato
  constante n Bits
  funct -> soma

MOV rX, A
opcode -> MOV
número do registrador
funct -> Acumulador para Reg.

MOV A, rX
opcode -> MOV
número do registrador
funct -> Reg. para Acumulador

SUBB??

CMPR A, rY
opcode -> CMP
número do registrador
funct -> ?


CMPI A, const
opcode -> imediato
constante n Bits
funct -> CMP

JUMP endereço
opcode -> jump
constante n Bits -> endereço



BEQ const

BHS const

Uma subtração com _Borrow_ ocorre na operação $a − b$ quando b é maior 
que a, tratando-os como números sem sinal.
O hardware do computador pode detectar um empréstimo 
na subtração verificando se ocorreu um "carry" na adição
correspondente. Se não houver carry na adição,
então há um _Borrow_ na subtração.
Se houver carry na adição, então não há empréstimo na subtração.

SUBB = a + not(b) + Cf, sendo Cf a Carry Flag.



Lab5
R --  funct register0 register1 opcode ?
I --  const register0 register1 opcode ?
B --  const opcode ?

LD Rx, const

ADD A, Rx

MOVE A, Rx (mover o conteudo de A para Rx)

MOVE Rx, A -> (mover o conteudo de Rx para A)

MOVE Rx, Ry -> (mover o conteudo de Rx para Ry) ???
-- O processador deveria ser capaz de mover valor entre
-- registradores ou apenas entre registradores e acumulador?

JUMP const -> (ja tá implementada mas é meio capenga)

