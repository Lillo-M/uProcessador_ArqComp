R --  funct register0 register1 opcode
I --  const register opcode
B --  const opcode




ADD A, rX
opcode -> soma
número do registrador
funct -> soma

LD rX, const
opcode -> soma
número do registrador
funct -> soma


SUB A, rX
opcode -> soma
número do registrador
funct -> sub

SUBI A, const
opcode -> imediato
constante n Bits
funct -> sub

opcional:
  ADDI A, const
  opcode -> imediato
  constante n Bits
  funct -> soma

MOV rX, A
opcode -> MOV
número do registrador
funct -> Acumulador para Reg.

MOV A, rX
opcode -> MOV
número do registrador
funct -> Reg. para Acumulador

SUBB??

CMPR A, rY
opcode -> CMP
número do registrador
funct -> ?


CMPI A, const
opcode -> imediato
constante n Bits
funct -> CMP

JUMP endereço
opcode -> jump
constante n Bits -> endereço



BEQ const

BHS const

Uma subtração com _Borrow_ ocorre na operação $a − b$ quando b é maior 
que a, tratando-os como números sem sinal.
O hardware do computador pode detectar um empréstimo 
na subtração verificando se ocorreu um "carry" na adição
correspondente. Se não houver carry na adição,
então há um _Borrow_ na subtração.
Se houver carry na adição, então não há empréstimo na subtração.

SUBB = a + not(b) + Cf, sendo Cf a Carry Flag.



Lab5
R --  funct register0 opcode
I --  const opcode
B --  const opcode
J --  const opcode

LD A, const
opcode = 0001

ADD A, Rx
opcode = 0010

SUBI A, const
opcode = 0011

SUBB A, const
opcode = 0100

CMPR A, Rx
opcode = 0101

CMPI A, const
opcode = 0110

MOVE A, Rx (mover o conteudo de A para Rx)
opcode = 0111

MOVE Rx, A -> (mover o conteudo de Rx para A)
opcode = 1000


BHS const
opcode = 1101

BEQ const
opcode = 1110

JUMP const -> (ja tá implementada mas é meio capenga)
opcode = 1111

B J I 
| const 16 downto 4 | opcode 3 downto 0 |
  0 0000 0000 0000          0000

R
| rs1 ..3 bits.. | opcode  3 downto 0|
      000                 0000
